$date
	Tue Mar  7 02:31:00 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module ripple_carry_adder_tb $end
$var wire 8 ! sum [7:0] $end
$var wire 1 " carry_out $end
$var reg 8 # a [7:0] $end
$var reg 8 $ b [7:0] $end
$scope module dut $end
$var wire 8 % a [7:0] $end
$var wire 8 & b [7:0] $end
$var wire 1 ' cin $end
$var wire 8 ( sum [7:0] $end
$var wire 1 " cout $end
$var wire 1 ) c7 $end
$var wire 1 * c6 $end
$var wire 1 + c5 $end
$var wire 1 , c4 $end
$var wire 1 - c3 $end
$var wire 1 . c2 $end
$var wire 1 / c1 $end
$scope module fa0 $end
$var wire 1 0 a $end
$var wire 1 1 b $end
$var wire 1 ' cin $end
$var wire 1 / cout $end
$var wire 1 2 sum $end
$upscope $end
$scope module fa1 $end
$var wire 1 3 a $end
$var wire 1 4 b $end
$var wire 1 / cin $end
$var wire 1 . cout $end
$var wire 1 5 sum $end
$upscope $end
$scope module fa2 $end
$var wire 1 6 a $end
$var wire 1 7 b $end
$var wire 1 . cin $end
$var wire 1 - cout $end
$var wire 1 8 sum $end
$upscope $end
$scope module fa3 $end
$var wire 1 9 a $end
$var wire 1 : b $end
$var wire 1 - cin $end
$var wire 1 , cout $end
$var wire 1 ; sum $end
$upscope $end
$scope module fa4 $end
$var wire 1 < a $end
$var wire 1 = b $end
$var wire 1 , cin $end
$var wire 1 + cout $end
$var wire 1 > sum $end
$upscope $end
$scope module fa5 $end
$var wire 1 ? a $end
$var wire 1 @ b $end
$var wire 1 + cin $end
$var wire 1 * cout $end
$var wire 1 A sum $end
$upscope $end
$scope module fa6 $end
$var wire 1 B a $end
$var wire 1 C b $end
$var wire 1 * cin $end
$var wire 1 ) cout $end
$var wire 1 D sum $end
$upscope $end
$scope module fa7 $end
$var wire 1 E a $end
$var wire 1 F b $end
$var wire 1 ) cin $end
$var wire 1 " cout $end
$var wire 1 G sum $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
1G
0F
0E
0D
0C
1B
0A
1@
0?
0>
1=
1<
1;
0:
09
08
07
16
05
14
03
02
11
10
1/
1.
1-
0,
1+
1*
1)
b10001000 (
0'
b110011 &
b1010101 %
b110011 $
b1010101 #
0"
b10001000 !
$end
#10
